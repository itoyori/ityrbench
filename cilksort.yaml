depends:
  - name: massivethreads-dm
    recipe: release
  - name: pcas
    recipe: release
  - name: massivelogger
    recipe: release
  - name: backward-cpp
    recipe: v1.6
  - name: jemalloc
    recipe: v5.3.0

default_params:
  nodes: 1
  cores:
    - value: 48
      machines: [wisteria-o]
    - value: 36
      machines: [ito-a]
    - value: 6
      machines: [local]
  elem_type: int
  n_input: 1_000_000
  repeats: 10
  verify: 1
  cutoff_i: 64
  cutoff_q: 16384
  cutoff_m: "`$cutoff_q * 4`"
  exec_type: 2 # 0:serial/1:std::sort/2:parallel
  cache_policy: writeback_lazy # serial/nocache/writethrough/writeback/writeback_lazy
  dist_policy: cyclic # block/cyclic
  cache_size: 128 # MB
  block_size: 65536 # bytes
  max_dirty: 0.2 # ratio
  shared_mem: 1
  logger: dummy # dummy/trace/stats
  allocator: jemalloc # sys/jemalloc

default_name: cilksort
default_queue: node_${nodes}
default_duplicates: 3

batches:
  serial:
    params:
      nodes: 1
      cores: 1
      exec_type: [0, 1] # serial, std_sort
      n_input: 1_000_000_000
      repeats: 11
      cache_policy: serial
    duplicates: 1
    artifacts:
      - type: stdout
        dest: ${batch_name}/n_${n_input}_exec_${exec_type}_${duplicate}.log
      - type: stats
        dest: ${batch_name}/n_${n_input}_exec_${exec_type}_${duplicate}.stats
      - type: file
        src: mpirun_out.txt
        dest: ${batch_name}/n_${n_input}_exec_${exec_type}_${duplicate}.out

  scale1G:
    name: cilksort_${batch_name}
    params:
      nodes:
        - value: [1, 2, 2x3, 2x3x2, 3x4x3, 6x6x4]
        # - value: [1, 2, 2x3, 2x3x2, 3x4x3, 6x6x4, 8x9x8]
          machines: [wisteria-o]
        - value: [1, 2, 4, 8, 16]
          machines: [ito-a]
      n_input: 1_000_000_000
      repeats: 11
      cache_policy: [nocache, writethrough, writeback, writeback_lazy]
      logger: stats
    artifacts:
      - type: stdout
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.log
      - type: stats
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.stats
      - type: file
        src: mpirun_out.txt
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.out

  scale10G:
    name: cilksort_${batch_name}
    params:
      nodes:
        - value: [2x3x2, 3x4x3, 6x6x4]
        # - value: [2x3x2, 3x4x3, 6x6x4, 8x9x8]
          machines: [wisteria-o]
      n_input: 10_000_000_000
      repeats: 11
      cache_policy: [nocache, writethrough, writeback, writeback_lazy]
      logger: stats
    artifacts:
      - type: stdout
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.log
      - type: stats
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.stats
      - type: file
        src: mpirun_out.txt
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.out

  granularity:
    name: cilksort_${batch_name}
    params:
      nodes:
        - value: 2x3x2:torus
          machines: [wisteria-o]
      n_input: 10_000_000_000
      repeats: 11
      cutoff_q: [256, 1024, 4096, 16384, 65536]
      max_dirty: [0.05, 0.1, 0.2, 0.5, 1.0]
      logger: stats
    duplicates: 1
    artifacts:
      - type: stdout
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.log
      - type: stats
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.stats
      - type: file
        src: mpirun_out.txt
        dest: ${batch_name}/nodes_${nodes}_p_${cache_policy}_${duplicate}.out

build:
  depend_params: [elem_type, cache_policy, dist_policy, block_size, logger]
  script: |
    source common.bash

    CFLAGS="${CFLAGS:+$CFLAGS} -DNDEBUG"
    CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_BENCH_ELEM_TYPE=$KOCHI_PARAM_ELEM_TYPE"
    CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_LOGGER_IMPL=impl_$KOCHI_PARAM_LOGGER"
    CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_DIST_POLICY=$KOCHI_PARAM_DIST_POLICY"
    CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_BLOCK_SIZE=$KOCHI_PARAM_BLOCK_SIZE"

    case $KOCHI_PARAM_CACHE_POLICY in
      serial)         CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_POLICY=ityr_policy_serial" ;;
      nocache)        CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_POLICY=ityr_policy_workfirst -DITYR_IRO_DISABLE_CACHE=1" ;;
      writethrough)   CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_POLICY=ityr_policy_workfirst" ;;
      writeback)      CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_POLICY=ityr_policy_workfirst" ;;
      writeback_lazy) CFLAGS="${CFLAGS:+$CFLAGS} -DITYR_POLICY=ityr_policy_workfirst_lazy" ;;
      *)              echo "Unknown cache policy ($KOCHI_PARAM_CACHE_POLICY)"; exit 1 ;;
    esac

    make clean
    MPICXX=$MPICXX CFLAGS=$CFLAGS make cilksort.out

run:
  depend_params: [nodes, cores, n_input, repeats, verify, cutoff_i, cutoff_m, cutoff_q, exec_type, cache_policy, cache_size, max_dirty, shared_mem, logger, allocator]
  script: |
    source common.bash

    export PCAS_ENABLE_SHARED_MEMORY=$KOCHI_PARAM_SHARED_MEM
    export PCAS_MAX_DIRTY_CACHE_SIZE=$(bc <<< "$KOCHI_PARAM_CACHE_SIZE * 2^20 * $KOCHI_PARAM_MAX_DIRTY / 1")
    export PCAS_PREFETCH_BLOCKS=0

    case $KOCHI_PARAM_CACHE_POLICY in
      serial)         ;;
      nocache)        ;;
      writethrough)   export PCAS_ENABLE_WRITE_THROUGH=1 ;;
      writeback)      ;;
      writeback_lazy) ;;
      *)              echo "Unknown cache policy ($KOCHI_PARAM_CACHE_POLICY)"; exit 1 ;;
    esac

    export MADM_STACK_SIZE=$((4 * 1024 * 1024))
    n_nodes=$(echo $KOCHI_PARAM_NODES | cut -f 1 -d ":" | sed 's/x/*/g' | bc)

    if [[ $KOCHI_PARAM_ALLOCATOR == jemalloc ]]; then
      export LD_PRELOAD=${KOCHI_INSTALL_PREFIX_JEMALLOC}/lib/libjemalloc.so${LD_PRELOAD:+:$LD_PRELOAD}
    fi

    ityr_mpirun $((n_nodes * KOCHI_PARAM_CORES)) $KOCHI_PARAM_CORES ./cilksort.out \
      -n $KOCHI_PARAM_N_INPUT \
      -r $KOCHI_PARAM_REPEATS \
      -e $KOCHI_PARAM_EXEC_TYPE \
      -c $KOCHI_PARAM_CACHE_SIZE \
      -v $KOCHI_PARAM_VERIFY \
      -i $KOCHI_PARAM_CUTOFF_I \
      -m $KOCHI_PARAM_CUTOFF_M \
      -q $KOCHI_PARAM_CUTOFF_Q

    # jeprof_wrap() {
    #   # FILEPATH=jeprof.${PMIX_RANK}.out
    #   FILEPATH=/work/gc64/c64050/jeprof/cilksort.${PMIX_RANK}
    #   export MALLOC_CONF="prof:true,lg_prof_interval:30,prof_prefix:$FILEPATH"
    #   "$@"
    # }
    # export -f jeprof_wrap

    # ityr_mpirun $((n_nodes * KOCHI_PARAM_CORES)) $KOCHI_PARAM_CORES bash -c "jeprof_wrap ./cilksort.out \
    #   -n $KOCHI_PARAM_N_INPUT \
    #   -r $KOCHI_PARAM_REPEATS \
    #   -e $KOCHI_PARAM_EXEC_TYPE \
    #   -c $KOCHI_PARAM_CACHE_SIZE \
    #   -v $KOCHI_PARAM_VERIFY \
    #   -i $KOCHI_PARAM_CUTOFF_I \
    #   -m $KOCHI_PARAM_CUTOFF_M \
    #   -q $KOCHI_PARAM_CUTOFF_Q"

    if [[ $KOCHI_PARAM_LOGGER == trace ]]; then run_trace_viewer; fi
